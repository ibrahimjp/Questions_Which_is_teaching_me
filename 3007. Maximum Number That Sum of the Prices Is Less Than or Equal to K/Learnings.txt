Question Statement :- 

3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K
You are given an integer k and an integer x. The price of a number num is calculated by the count of set bits at positions x, 2x, 3x, etc., in its binary representation, starting from the least significant bit. The following table contains examples of how price is calculated.

x	num	Binary Representation	Price
1	13	000001101	3
2	13	000001101	1
2	233	011101001	3
3	13	000001101	1
3	362	101101010	2
The accumulated price of num is the total price of numbers from 1 to num. num is considered cheap if its accumulated price is less than or equal to k.

Return the greatest cheap number.

The Constraints :- 
1 <= k <= 10^15
1 <= x <= 8


# the problem make me learning a new topic i didn't know previously 
it is a bit intresting problem giving the good observation which will make a good impact on the future problems 

# the brute force is pretty simple just do binary search and figure out the sum of all bit count till mid 

the optimal one :- 

now understand it very well the youtube vedio (watch from 30:04):- https://www.youtube.com/watch?v=D5yhQ-bqw9E&ab_channel=codestorywithMIK

suppose we need to find the bitCount till 12 
0000   (0)
0001   (1) -> 2^0
0010   (2)
0011   (3)
0100   (4) -> 2^2
0101   (5)
0110   (6)
0111   (7)
1000   (8) -> 2^4
1001   (9)
1010   (10)
1100   (11)
1101   (12)


we just represent all the number in the form of power of 2 
so i have to find the array [0,0,0,0] which stores the number of set bits as a whole  from 0 to that number here i can represnt all the thing in 4 bit integer so i just took 4 size array at the last the array will be storing [5,6,4,6] ans then we traverse throunght the array and say if i % x  == 0 then just add that number and check if the sum <= k or not than we go left or right depeds on That

so the observation is find the nearest power of 2 how (countBitLen(which is currently 4)) then just do (12(because currently we are figuring about 12) ^ countBitLen - 1);

this will give you the nearest power of 2 then on the first index you just can do number(12) - countBitLen + 1
[5,0,0,0]

now you are at the nearest power of 2 then just observe that after this operation when you sum all the bits on the all the columns(from 0 to nearest power of 2 which is 8 in this case) it will be countBitLen / 2 for every column 

this is a great property of bitManipulation now your array has becme [5,4,4,4]
now just subtract 12 - nearest power which is 8 then perform all the opertions again from 12 - 8 = 4
 at the last the array would became [5,6,4,6]



 Deeply explaination :- 

 Imagine you are counting set bits (1s) in binary numbers from 1 up to some number n.
Let’s say you want to know how many times each bit — say the 0th bit, 1st bit, 2nd bit, and so on — is set in all the numbers from 1 to 12. You look at the binary form of all numbers from 1 to 12:

Decimal   Binary
1         0001
2         0010
3         0011
4         0100
5         0101
6         0110
7         0111
8         1000
9         1001
10        1010
11        1011
12        1100


Now, you count the number of 1s in each bit position across all these numbers.

Let’s do it manually.

For the 0th bit (the rightmost bit): it's set in numbers like 1, 3, 5, 7, 9, 11 → 6 times

For the 1st bit: set in 2, 3, 6, 7, 10, 11 → also 6 times

For the 2nd bit: 4, 5, 6, 7, 12 → 5 times

For the 3rd bit: 8, 9, 10, 11, 12 → again 5 times

Now that we see this, the big question is — how would you figure this out without checking every number?

Here is where the real observation comes in. It starts with a core insight about how binary numbers work in powers of two.



Bit patterns emerge in ranges of powers of 2
Binary numbers are not just digits — they grow with patterns. These patterns emerge in ranges based on powers of 2.

From 0 to 1 → 2 numbers → 2^1

From 0 to 3 → 4 numbers → 2^2

From 0 to 7 → 8 numbers → 2^3

From 0 to 15 → 16 numbers → 2^4

In each of these ranges, the set bits behave predictably.

For example, in numbers from 0 to 7 (which is 2^3 - 1), the 0th bit (rightmost) is set in half of the numbers — 4 times. The same applies to the 1st bit and 2nd bit.

Why?

Because the pattern repeats every 2, 4, 8 positions.

The 0th bit toggles every 1 number → ON, OFF, ON, OFF…

The 1st bit toggles every 2 numbers → ON for 2, OFF for 2…

The 2nd bit toggles every 4 numbers…

So, in a full block of 2^n numbers (starting from 0), each bit i is set in exactly 2^{n - 1} numbers. In other words: in half the numbers of that block, that bit is 1.

This is not a guess. It is a mathematical property of binary counting.

So, from 0 to 7:

The 0th bit is set in 4 numbers

The 1st bit is set in 4 numbers

The 2nd bit is set in 4 numbers

And this will always be true for full powers of 2.

What about numbers that don’t go exactly up to a power of 2?
Let’s take your example: 12.

The nearest power of 2 less than or equal to 12 is 8 → which is 2^3.

So we say:

First, count set bits in all numbers from 0 to 7 → we already know how many each bit has: 4 for bits 0, 1, and 2

Then, handle numbers from 8 to 12 manually (but using the same principle)

Now, from 8 to 12, the total is 5 numbers. This isn’t a complete block of 2^n, so we can’t use the pattern directly.

But we can still reuse our previous counts and just add the contributions of the remaining 5 numbers.

Let’s look at number 12 (1100):

Its highest set bit is at position 3

So we say: the 3rd bit is set from 8 to 12 in all numbers where it is 1. Specifically, bit 3 is set in numbers 8, 9, 10, 11, and 12 → 5 times

We add 5 to bitCount[3]

Now, we subtract 8 (2^3) from 12 → we’re left with 4.

So, we repeat everything on number 4.

This time:

4’s highest set bit is at position 2

Nearest power of 2: 4 → 2^2

Numbers from 0 to 3 have a predictable pattern again

bit 0: ON in 2 of them

bit 1: ON in 2

bit 2: OFF

But number 4 itself has bit 2 set, so we manually add +1 to bitCount[2]

You keep repeating this — recursively — breaking your number into pieces that end at the nearest lower power of two, and using patterns to fill in how many times each bit is set.

Summary of the Observation
So here’s the complete understanding a child must walk away with:

Binary numbers build in predictable patterns over powers of 2

Within a complete block [0 ... 2^n - 1], each bit i is set exactly in half the numbers

To find how many times a bit is set from 1 to n, you:

Decompose n by subtracting the nearest power of 2 repeatedly

Use the patterns for blocks and manually add contributions for leftovers

This approach is fast, elegant, and avoids checking every single number

It’s not a trick. It’s a property of how binary counting grows.

Once you understand that in blocks of powers of 2, the bits behave identically, then everything else becomes a matter of adding those contributions up.

This understanding is crucial. It shows up in many hard problems — not just this one. You’ll start seeing it in questions where you count set bits, sum bits, or simulate digital systems. It's a core building block of bitwise thinking.

