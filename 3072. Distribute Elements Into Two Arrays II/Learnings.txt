new Trick unlocked 

Letâ€™s First Understand: What Problem Is This Segment Tree Solving?
We are solving this problem:

Split an array nums[] into two arrays a and b, such that for every element, we check how many greater elements are already in a and b.
We place the element into the array that has more greater elements.

ğŸ’¡ Real Goal:
Simulate the effect of maintaining two sorted arrays dynamically and using that info in real-time.


Why Segment Tree?
You want to ask questions like:

â€œHow many numbers greater than x are already inserted in a[]?â€

You canâ€™t use a normal array or list for this efficiently because:

Checking how many greater elements â†’ takes O(n) each time.

We need it fast â†’ Segment Tree = O(log n)


What's the Segment Tree Tracking?
Letâ€™s say your sorted version of nums[] is:

sorted = [2, 3, 4, 6]
index     0  1  2  3

The segment tree is like a frequency map over this sorted array. Initially
tree = [0, 0, 0, 0]

If you insert 4 (i.e., index 2 in sorted array), tree becomes
tree = [0, 0, 1, 0]

Now you want to know:

How many numbers greater than 3 (index = 1) have already been inserted?

Query the segment tree for the range [2, 3] â†’ gives you 1 (because 4 is inserted).

# FULL WORKED EXAMPLE
nums = [4, 2, 6, 3]
Step-by-step:

ğŸ”¹ Step 1: Build Sorted Version + Mapped Index
Sorted = [2, 3, 4, 6]
So each number maps to:

| nums\[i] | mapped\[i] |
| -------- | ---------- |
| 4        | 2          |
| 2        | 0          |
| 6        | 3          |
| 3        | 1          |

Step 2: Initialize Arrays + Segment Trees
a = [4], b = [2]

Update segment trees:

treeA inserts index 2 â†’ [0, 0, 1, 0]

treeB inserts index 0 â†’ [1, 0, 0, 0]

Step 3: Now process next number â†’ 6 (mapped index = 3)
Use upperBound(6) â†’ gives index = 4 (nothing is strictly greater)

query(treeA, 4, 3) â†’ 0

query(treeB, 4, 3) â†’ 0

They are equal. Now choose shorter array.

b is shorter â†’ insert 6 to b

Update treeB: index 3 â†’ [1, 0, 0, 1]

ğŸ”¹ Step 4: Next number â†’ 3 (mapped = 1)
upperBound(3) â†’ index = 2 (for 4 and 6)

query(treeA, 2, 3) â†’ 1 (4)

query(treeB, 2, 3) â†’ 1 (6)

Equal! So check sizes:

a has [4]

b has [2, 6]

So insert in a â†’ [4, 3], update treeA: index 1 â†’ [0, 1, 1, 0]

âœ… Final:

a = [4, 3]

b = [2, 6]

result = [4, 3, 2, 6]

ğŸ’¡ But Wait â€” Why Not Use TreeMap or Binary Search?
You could, but:

TreeMap has log(n) insert + log(n) count

But if you need prefix or suffix sum of counts quickly and updates happen a lot, segment tree is better

Also coordinate compression is needed if the range is large â€” and segment tree handles this neatly.

ğŸ”¥ When to Use This Segment Tree Pattern
Use it when you need:

âœ… Insertion + Count of numbers satisfying a condition:
How many numbers greater than X?

How many less than Y?

How many equal to Z?

And these values are coming online, one-by-one.

| Problem Idea                               | Data Structure           |
| ------------------------------------------ | ------------------------ |
| Count of greater/smaller elements after me | Segment Tree / BIT       |
| Inversion Count in Array                   | Segment Tree / BIT       |
| Online k-th smallest element               | Segment Tree / Order Set |
| Dynamic Median Maintenance                 | Multiset / Segment Tree  |
| Reconstructing a permutation               | Segment Tree             |
| Rank of elements while streaming data      | Segment Tree             |
| Number of inversions with duplicates       | Segment Tree             |
| Counting frequency in a range              | Segment Tree             |
