ğŸŒ³ What is Re-rooting DP?
Imagine a tree (not the green leafy one ğŸƒ, but a graph with no cycles). This tree has n nodes connected with n-1 edges.

You pick one node as the root and try to solve a problem from there. But then you think:

â€œWait, what if another node was the root? Would the answer be better?â€

You want to try all nodes as root, but you don't want to redo everything from scratch every time. Thatâ€™s where Re-rooting DP comes in â€” it's a trick to reuse your old calculations and avoid repeating work.

ğŸ“˜ Key Problem: Tree Diameter
You're asked to find the maximum depth from every node if it were the root.

This is useful for finding the diameter of a tree (longest distance between any two nodes), or in your problem: minimum diameter after merging two trees.

ğŸ§  Step-by-Step: Re-rooting DP
Weâ€™ll understand the process through two phases: in[] and out[].

ğŸ“¦ Phase 1: in[] â†’ Bottom-Up
Letâ€™s say the tree is like this:
      0
     / \
    1   2
       / \
      3   4

We're calculating in[], which means:

From node X down to its deepest leaf, how far can we go?

in[src] = 1 + max(in[children])
Think of it like a package being passed up from the leaves.

Each child sends its â€œdepth giftâ€ to its parent.

Parent takes the maximum and adds 1.

In our example:

Leaves 1, 3, and 4 have in-depth = 1

Node 2 gets max of 3 and 4 â†’ in[2] = 1 + max(1, 1) = 2

Node 0 gets max of 1 and 2 â†’ in[0] = 1 + max(1, 2) = 3

Phase 2: out[] â†’ Top-Down
Now we do out calculation, which means:

Whatâ€™s the max depth you can reach going UP from a node, not down?

This phase is a little tricky, but magical.


      0
     / \
    1   2
       / \
      3   4

Hereâ€™s the idea:

When you're at a node, you know your best depth DOWN (from in[]).

You now pass the best alternative path UP to each child.

ğŸ˜² But Wait... Why do we need TWO maxes?
Because if one child had the best in[], and you're passing that to the same child again, it would be cheating. So:

You find the two largest in[]s among children (mx1 and mx2)

If a child X has mx1, you give it mx2 instead.

That way, every child gets the best answer from outside its own subtree.

The formula:

out[child] = max(1 + out[parent], 1 + (child == mx1 ? mx2 : mx1));


Letâ€™s Simulate a Small Example:
Say we have:

     0
    / \
   1   2


in[] Phase:
Leaf nodes 1 and 2 â†’ in = 1

Node 0 â†’ in = 1 + max(1, 1) = 2

in[] = [2, 1, 1]

out[] Phase:
From node 0, it has 2 children with in[] = 1, 1

max1 = 1, max2 = 1

For node 1:
out[1] = max(1 + out[0], 1 + max2) = 1 + 0 = 1 + 1 = 2

For node 2:
same â†’ out[2] = 2

Final:

Node 0 max depth = max(in[0], 1 + out[0]) = 2

Node 1 = max(1, 1 + 2) = 3

Node 2 = 3

So every node knows its maximum reachable depth if it were the root.

ğŸ”„ Re-rooting = Using in[] and out[] to simulate:
"What if THIS node were the root?"

Efficiently computed in O(n) time using DP

ğŸ’¥ Application in Your Code
Youâ€™re merging two trees.

Compute depth from each node as root using in[] and out[].

Find max depth for each tree.

Pick nodes with smallest max depth from both trees to connect.

The new diameter is:
max(maxDepth1, maxDepth2, depth1[min1] + depth2[min2])


Summary Like You're 5
You pass messages from the bottom to the top (in[]) saying â€œhow far can I go down?â€

Then you pass messages from the top to the bottom (out[]) saying â€œhow far can I go up and sideways?â€

Now every node knows how deep the tree would look if it were the root.

This saves tons of time, and lets you solve problems like:

Finding tree diameter

Finding best root

Merging trees with minimum diameter

