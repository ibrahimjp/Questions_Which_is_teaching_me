🌳 What is Re-rooting DP?
Imagine a tree (not the green leafy one 🍃, but a graph with no cycles). This tree has n nodes connected with n-1 edges.

You pick one node as the root and try to solve a problem from there. But then you think:

“Wait, what if another node was the root? Would the answer be better?”

You want to try all nodes as root, but you don't want to redo everything from scratch every time. That’s where Re-rooting DP comes in — it's a trick to reuse your old calculations and avoid repeating work.

📘 Key Problem: Tree Diameter
You're asked to find the maximum depth from every node if it were the root.

This is useful for finding the diameter of a tree (longest distance between any two nodes), or in your problem: minimum diameter after merging two trees.

🧠 Step-by-Step: Re-rooting DP
We’ll understand the process through two phases: in[] and out[].

📦 Phase 1: in[] → Bottom-Up
Let’s say the tree is like this:
      0
     / \
    1   2
       / \
      3   4

We're calculating in[], which means:

From node X down to its deepest leaf, how far can we go?

in[src] = 1 + max(in[children])
Think of it like a package being passed up from the leaves.

Each child sends its “depth gift” to its parent.

Parent takes the maximum and adds 1.

In our example:

Leaves 1, 3, and 4 have in-depth = 1

Node 2 gets max of 3 and 4 → in[2] = 1 + max(1, 1) = 2

Node 0 gets max of 1 and 2 → in[0] = 1 + max(1, 2) = 3

Phase 2: out[] → Top-Down
Now we do out calculation, which means:

What’s the max depth you can reach going UP from a node, not down?

This phase is a little tricky, but magical.


      0
     / \
    1   2
       / \
      3   4

Here’s the idea:

When you're at a node, you know your best depth DOWN (from in[]).

You now pass the best alternative path UP to each child.

😲 But Wait... Why do we need TWO maxes?
Because if one child had the best in[], and you're passing that to the same child again, it would be cheating. So:

You find the two largest in[]s among children (mx1 and mx2)

If a child X has mx1, you give it mx2 instead.

That way, every child gets the best answer from outside its own subtree.

The formula:

out[child] = max(1 + out[parent], 1 + (child == mx1 ? mx2 : mx1));


Let’s Simulate a Small Example:
Say we have:

     0
    / \
   1   2


in[] Phase:
Leaf nodes 1 and 2 → in = 1

Node 0 → in = 1 + max(1, 1) = 2

in[] = [2, 1, 1]

out[] Phase:
From node 0, it has 2 children with in[] = 1, 1

max1 = 1, max2 = 1

For node 1:
out[1] = max(1 + out[0], 1 + max2) = 1 + 0 = 1 + 1 = 2

For node 2:
same → out[2] = 2

Final:

Node 0 max depth = max(in[0], 1 + out[0]) = 2

Node 1 = max(1, 1 + 2) = 3

Node 2 = 3

So every node knows its maximum reachable depth if it were the root.

🔄 Re-rooting = Using in[] and out[] to simulate:
"What if THIS node were the root?"

Efficiently computed in O(n) time using DP

💥 Application in Your Code
You’re merging two trees.

Compute depth from each node as root using in[] and out[].

Find max depth for each tree.

Pick nodes with smallest max depth from both trees to connect.

The new diameter is:
max(maxDepth1, maxDepth2, depth1[min1] + depth2[min2])


Summary Like You're 5
You pass messages from the bottom to the top (in[]) saying “how far can I go down?”

Then you pass messages from the top to the bottom (out[]) saying “how far can I go up and sideways?”

Now every node knows how deep the tree would look if it were the root.

This saves tons of time, and lets you solve problems like:

Finding tree diameter

Finding best root

Merging trees with minimum diameter

