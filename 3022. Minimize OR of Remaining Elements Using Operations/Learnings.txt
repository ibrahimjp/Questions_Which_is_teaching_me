problem statement :- 
You are given a 0-indexed integer array nums and an integer k.

In one operation, you can pick any index i of nums such that 0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND operator.

Return the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations. 


Example 1:

Input: nums = [3,5,3,2,7], k = 2
Output: 3
Explanation: Let's do the following operations:
1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [1,3,2,7].
2. Replace nums[2] and nums[3] with (nums[2] & nums[3]) so that nums becomes equal to [1,3,2].
The bitwise-or of the final array is 3.
It can be shown that 3 is the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.


.

# okay so we will play here greedily imagine you have an 32 bit integer array consist of all 32 bit integers and have to represent is in matrix form 

suppose :- nums = [3,5,3,2,7]
     3 , 5 , 3 , 2 , 7
2^0  0   0   0   0   0
2^1  0   1   0   0   1
2^2  1   0   1   1   1
2^3  1   0   1   0   1


# Key Observation — What Does It Take to Remove 1s?


Suppose we want to remove all 1s in a row (2^1 = row [1, 0, 1, 0, 1]):

To remove all 1s using & operations, we combine adjacent elements, and whenever we do a & b, the result will only have 1s where both a and b had 1s.

So this helps us reduce the number of 1s. But we must be smart about how many such combinations (operations) we need.

Here's the observation:
We divide the array into segments of adjacent elements where this bit is 1.
In each segment, we can combine them (using &) to try and make that bit disappear.
But we must count how many operations are needed to eliminate the bit from that group.

There are two cases in each segment:
1. If the combined result eventually has that bit OFF → we needed (length - 1) operations.
2. If the combined result still has the bit ON → we needed length operations (we couldn’t turn it off entirely).
We repeat this process for every bit, from high to low, and greedily try to keep only those bits we are unable to turn off within k operations.


# Wrapping it All Up:

So we build our result ans bit by bit, starting from the most significant one:
For each bit, we try to turn it off using a helper function that calculates how many operations it would take.
If it’s possible in ≤ k operations → good, skip that bit.
If not → we must include that bit in the final answer (because we can’t get rid of it).
In the end, ans will have all the bits that we couldn't eliminate. That’s the minimum OR value we can get after at most k AND operations.

